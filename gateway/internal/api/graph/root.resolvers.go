package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"errors"
	"fmt"
	auth "gateway/internal"
	"gateway/internal/api/graph/model"
	"gateway/internal/models"
	"log"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, input model.RegistrationRequest) (*model.RegistrationResponse, error) {
	log.Printf("resolver: register invoked")

	request := convertRegRequestDTOtoRegRequestModel(input)
	regResponse, err := r.userService.Register(ctx, request)

	if err != nil {
		log.Printf("resolver: user service err: %v", err)
		return nil, err
	}

	return convertRegResponseModeltoRegResponseDTO(regResponse), nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginRequest) (*model.LoginResponse, error) {
	log.Printf("resolver: login invoked")

	request := convertLoginRequestDTOtoLoginRequestModel(input)
	loginResponse, err := r.userService.Login(ctx, request)

	if err != nil {
		log.Printf("resolver: user service fail: %v", err)
		return nil, err
	}

	return convertLoginResponseModeltoLoginResponseDTO(loginResponse), nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.CreateUserInput) (*model.CreateUserResponse, error) {
	log.Printf("resolver: CreateUser invoked")
	// authData := ctx.Value("auth")
	// if authData == nil {
	// 	return nil, errors.New("not authorized")
	// }

	user := &models.User{
		ID:           0,
		FirstName:    input.FirstName,
		SecondName:   input.SecondName,
		LastName:     input.LastName,
		Email:        input.Email,
		Password:     input.Password,
		PassportData: input.PassportData,
		BirthDate:    input.BirthDate,
		Gender:       models.Gender(input.Gender),
		Isblocked:    false,
		Role:         models.UserRole(input.Role),
		Status:       models.UserStatus(input.Status),
	}

	_, err := r.userService.Create(ctx, nil, user)
	if err != nil {
		return nil, err
	}

	return &model.CreateUserResponse{
		Status: 200,
	}, nil
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input model.UpdateUserRequest) (*model.UpdateUserResponse, error) {
	log.Printf("resolver: UpdateUser invoked")
	// authData := ctx.Value("auth")
	// if authData == nil {
	// 	return nil, errors.New("not authorized")
	// }
	log.Println(input)
	user := MapUpdateUserRequestToUser(input)
	// _, err := r.userService.Update(ctx, authData.(*auth.AuthData), input.ID, &user)
	_, err := r.userService.Update(ctx, nil, input.ID, &user)

	if err != nil {
		return nil, err
	}

	return &model.UpdateUserResponse{
		Status: 200,
	}, nil
}

// DeleteUser is the resolver for the deleteUser field.
func (r *mutationResolver) DeleteUser(ctx context.Context, userID int) (*model.DeleteUserResponse, error) {
	// authData := ctx.Value("auth")
	// if authData == nil {
	// 	return nil, errors.New("not authorized")
	// }

	return &model.DeleteUserResponse{
		Status: 0,
	}, r.userService.Delete(ctx, nil, userID)
}

// CreateCredit is the resolver for the createCredit field.
func (r *mutationResolver) CreateCredit(ctx context.Context, input model.CreateCreditRequest) (*model.CreateCreditResponse, error) {
	log.Printf("resolver: CreateCredit invoked")

	credit := &models.Credit{
		UserID:         uint64(input.UserID),
		ApplicationID:  uint64(input.ApplicationID),
		Body:           uint64(input.Body),
		Percents:       uint64(input.Percents),
		Fine:           uint64(input.Fine),
		Commission:     uint64(input.Commission),
		IsActive:       input.IsActive,
		PaymentType:    models.PaymentType(input.PaymentType),
		InterestRate:   input.InterestRate,
		LoanTermMonths: uint(input.LoanTermMonths),
		StartDate:      input.StartDate,
		EndDate:        input.EndDate,
	}
	if err := r.creditService.Create(ctx, credit); err != nil {
		return nil, err
	}

	return &model.CreateCreditResponse{
		Success: true,
		Credit:  nil,
	}, nil
}

// UpdateCredit is the resolver for the updateCredit field.
func (r *mutationResolver) UpdateCredit(ctx context.Context, input model.UpdateCreditRequest) (*model.UpdateCreditResponse, error) {
	log.Printf("resolver: UpdateCredit invoked")
	credit := &models.Credit{
		ID:             uint64(input.ID),
		UserID:         uint64(*input.UserID),
		ApplicationID:  uint64(*input.ApplicationID),
		Body:           uint64(*input.Body),
		Percents:       uint64(*input.Percents),
		Fine:           uint64(*input.Fine),
		Commission:     uint64(*input.Commission),
		IsActive:       *input.IsActive,
		PaymentType:    models.PaymentType(*input.PaymentType),
		InterestRate:   *input.InterestRate,
		LoanTermMonths: uint(*input.LoanTermMonths),
		StartDate:      *input.StartDate,
		EndDate:        *input.EndDate,
	}
	if err := r.creditService.Update(ctx, credit); err != nil {
		return nil, err
	}

	return &model.UpdateCreditResponse{
		Success: true,
	}, nil
}

// DeleteCredit is the resolver for the deleteCredit field.
func (r *mutationResolver) DeleteCredit(ctx context.Context, creditID int) (*model.DeleteCreditResponse, error) {
	log.Printf("resolver: UpdateCredit invoked")
	if err := r.creditService.Delete(ctx, creditID); err != nil {
		return nil, err
	}

	return &model.DeleteCreditResponse{
		Success: true,
	}, nil
}

// CreateCreditTariff is the resolver for the createCreditTariff field.
func (r *mutationResolver) CreateCreditTariff(ctx context.Context, input model.CreditTariffInput) (*model.CreateCreditTariffResponse, error) {
	log.Printf("resolver: CreateCreditTariff invoked")
	tariff := &models.Tariff{
		Name:            input.Name,
		MinAmount:       input.MinAmount,
		MaxAmount:       input.MaxAmount,
		MinInterestRate: input.MinInterestRate,
		MaxInterestRate: input.MaxInterestRate,
		PaymentType:     models.PaymentType(input.PaymentType),
		MinTermMonth:    uint(input.MinTermMonth),
		MaxTermMonth:    uint(input.MaxTermMonth),
	}
	if input.Description != nil {
		tariff.Description = *input.Description
	}

	err := r.tariffService.Create(ctx, nil, tariff)
	if err != nil {
		return nil, err
	}

	return &model.CreateCreditTariffResponse{
		Status: 200,
	}, nil
}

// UpdateCreditTariff is the resolver for the updateCreditTariff field.
func (r *mutationResolver) UpdateCreditTariff(ctx context.Context, id int, input model.CreditTariffInput) (*model.UpdateCreditTariffResponse, error) {
	tariff := &models.Tariff{
		ID:              uint(id),
		Name:            input.Name,
		MinAmount:       input.MinAmount,
		MaxAmount:       input.MaxAmount,
		MinInterestRate: input.MinInterestRate,
		MaxInterestRate: input.MaxInterestRate,
		PaymentType:     models.PaymentType(input.PaymentType),
		MinTermMonth:    uint(input.MinTermMonth),
		MaxTermMonth:    uint(input.MaxTermMonth),
	}

	if input.Description != nil {
		tariff.Description = *input.Description
	}

	err := r.tariffService.Update(ctx, nil, tariff)
	if err != nil {
		return nil, err
	}

	return &model.UpdateCreditTariffResponse{
		Status: 200,
	}, nil
}

// DeleteCreditTariff is the resolver for the deleteCreditTariff field.
func (r *mutationResolver) DeleteCreditTariff(ctx context.Context, id int) (*model.DeleteCreditTariffResponse, error) {
	err := r.tariffService.Delete(ctx, nil, id)
	if err != nil {
		return nil, err
	}

	return &model.DeleteCreditTariffResponse{
		Status: 200,
	}, nil
}

// GetUsers is the resolver for the GetUsers field.
func (r *queryResolver) GetUsers(ctx context.Context, limit *int, offset *int) ([]*model.User, error) {
	// authData := ctx.Value("auth")
	// if authData == nil {
	// 	return nil, errors.New("not authorized")
	// }
	lim := 0
	off := 0
	if limit != nil {
		lim = *limit
	}
	if offset != nil {
		off = *offset
	}

	// Преобразуем модели базы данных в модели GraphQL
	//	graphqlUsers, err := r.userService.GetUsers(ctx, authData.(*auth.AuthData), lim, off)
	graphqlUsers, err := r.userService.GetUsers(ctx, nil, lim, off)
	return MapUsersToDTO(graphqlUsers), err
}

// GetUserByEmail is the resolver for the GetUserByEmail field.
func (r *queryResolver) GetUserByEmail(ctx context.Context, email string) (*model.User, error) {
	authData := ctx.Value("auth")
	if authData == nil {
		return nil, errors.New("not authorized")
	}
	user, err := r.userService.GetUserByEmail(ctx, authData.(*auth.AuthData), email)
	if err != nil {
		return nil, err
	}

	return MapUserToDTO(user), nil
}

// GetCredits is the resolver for the getCredits field.
func (r *queryResolver) GetCredits(ctx context.Context, limit *int, offset *int) ([]*model.Credit, error) {
	log.Printf("resolver: GetCredits invoked")
	creditsLimit := 0
	creditsOffset := 0
	if limit != nil {
		creditsLimit = *limit
	}
	if offset != nil {
		creditsOffset = *offset
	}

	credits, err := r.creditService.GetCredits(ctx, creditsLimit, creditsOffset)
	if err != nil {
		return nil, err
	}

	return MapCreditsToDTO(credits), nil
}

// GetCreditTariffByID is the resolver for the getCreditTariffByID field.
func (r *queryResolver) GetCreditTariffByID(ctx context.Context, id string) (*model.CreditTariff, error) {
	panic(fmt.Errorf("not implemented: GetCreditTariffByID - getCreditTariffByID"))
}

// GetCreditTariffs is the resolver for the getCreditTariffs field.
func (r *queryResolver) GetCreditTariffs(ctx context.Context, limit *int, offset *int) ([]*model.CreditTariff, error) {
	// Установим значения по умолчанию для limit и offset, если они не указаны
	defaultLimit := 10
	defaultOffset := 0

	if limit == nil {
		limit = &defaultLimit
	}
	if offset == nil {
		offset = &defaultOffset
	}

	// Используем сервис для получения списка тарифов
	tariffs, err := r.tariffService.GetTariffs(ctx, *limit, *offset)
	if err != nil {
		return nil, err
	}

	// Преобразуем тарифы из модели сервиса в модель GraphQL
	var result []*model.CreditTariff
	for _, t := range tariffs {
		result = append(result, &model.CreditTariff{
			ID:              int(t.ID),
			Name:            t.Name,
			MinAmount:       t.MinAmount,
			MaxAmount:       t.MaxAmount,
			MinInterestRate: t.MinInterestRate,
			MaxInterestRate: t.MaxInterestRate,
			PaymentType:     model.PaymentType(t.PaymentType),
			MinTermMonth:    int(t.MinTermMonth),
			MaxTermMonth:    int(t.MaxTermMonth),
			Description:     &t.Description,
		})
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
